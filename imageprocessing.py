# -*- coding: utf-8 -*-
"""Imageprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13v4xRTLrWCeLdwqM5y1w6L97FUqN8BSh
"""

#exp 1 dct
import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load an image
image = cv2.imread("/content/flower.jpg", cv2.IMREAD_GRAYSCALE)  # Remove the leading slash from the image path

# Ensure the image size is a multiple of 8 for DCT/IDCT
rows, cols = image.shape
if rows % 8 != 0 or cols % 8 != 0:
    new_rows = rows + 8 - (rows % 8)
    new_cols = cols + 8 - (cols % 8)
    image = cv2.resize(image, (new_cols, new_rows))

# Perform DCT
dct = cv2.dct(np.float32(image))

# Perform IDCT
idct = cv2.idct(dct)

# Convert back to uint8 and display the images
dct_uint8 = np.uint8(dct)
idct_uint8 = np.uint8(idct)

cv2_imshow(image)
cv2_imshow(dct_uint8)
cv2_imshow(idct_uint8)

#exp 2
import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load an image
image = cv2.imread('/content/flower.jpg', cv2.IMREAD_GRAYSCALE)

# Check if the image was loaded successfully
if image is None:
    print("Error: Could not open or find the image.")
else:
    # Perform image processing operations
    # Example: Contrast Stretching (Normalization)
    min_value = np.min(image)
    max_value = np.max(image)
    normalized_image = np.uint8(255 * (image - min_value) / (max_value - min_value))

    # Example: Histogram Equalization
    equalized_image = cv2.equalizeHist(image)

    # Example: Gamma Correction (Power Law Transformation)
    gamma = 1.5  # Adjust the gamma value as needed
    gamma_corrected = np.uint8(255 * np.power(image / 255.0, gamma))

    # Example: Logarithmic Transformation
    c = 255 / np.log(1 + np.max(image))
    log_transformed = np.uint8(c * np.log(image + 1))

    # Example: Thresholding
    threshold_value = 128
    _, thresholded_image = cv2.threshold(image, threshold_value, 255, cv2.THRESH_BINARY)

    # Display the images
    cv2_imshow(image)
    cv2_imshow(normalized_image)
    cv2_imshow(equalized_image)
    cv2_imshow(gamma_corrected)
    cv2_imshow(log_transformed)
    cv2_imshow(thresholded_image)

#exp 3 contrast enhancement
import cv2
from google.colab.patches import cv2_imshow

# Load the color image
image_path = "/content/flower.jpg"
color_image = cv2.imread(image_path)

# Check if the image was loaded successfully
if color_image is None:
    print("Error: Could not open or find the image.")
else:
    # Convert the color image to grayscale
    gray_image = cv2.cvtColor(color_image, cv2.COLOR_BGR2GRAY)

    # Apply histogram equalization to the grayscale image
    equalized_gray_image = cv2.equalizeHist(gray_image)

    # Split the color image into its RGB channels
    b, g, r = cv2.split(color_image)

    # Apply histogram equalization to each channel
    equalized_b = cv2.equalizeHist(b)
    equalized_g = cv2.equalizeHist(g)
    equalized_r = cv2.equalizeHist(r)

    # Merge the equalized channels back into a color image
    equalized_color_image = cv2.merge((equalized_b, equalized_g, equalized_r))

    # Display the original and equalized images using cv2_imshow
    cv2_imshow(color_image)
    cv2_imshow(gray_image)
    cv2_imshow(equalized_color_image)
    cv2_imshow(equalized_gray_image)

# exp4 edge detection
import cv2
import numpy as np
from matplotlib import pyplot as plt
# Load the image
img = cv2.imread('/content/flower.jpg', 0)  # Replace 'your_image_path.jpg' with the actual path
plt.imshow(img, cmap='gray')
plt.title('Original Image')
plt.show()
# Apply Laplacian filter for edge detection
laplacian = cv2.Laplacian(img, cv2.CV_64F)
# Convert the result back to uint8 for display
edges = cv2.convertScaleAbs(laplacian)
# Display the result
plt.imshow(edges, cmap='gray')
plt.title('Edges Detected using Laplacian')
plt.show()

#exp 5 restoration of original image
import numpy as np
import cv2
from matplotlib import pyplot as plt
# Load the corrupted image
img = cv2.imread('/content/flower.jpg', 0)  # Replace 'your_image_path.jpg' with the actual path
# Add Gaussian noise
mean = 0
var = 100
sigma = var ** 0.5
gaussian = np.random.normal(mean, sigma, img.shape).astype('uint8')
noisy_image = cv2.add(img, gaussian)
# Add impulse (salt and pepper) noise
s_vs_p = 0.5  # Salt to Pepper ratio
amount = 0.04  # Amount of noise
num_salt = np.ceil(amount * img.size * s_vs_p)
num_pepper = np.ceil(amount * img.size * (1.0 - s_vs_p))
# Generate random coordinates for salt and pepper
coords_salt = [np.random.randint(0, i-1, int(num_salt)) for i in img.shape]
coords_pepper = [np.random.randint(0, i-1, int(num_pepper)) for i in img.shape]
# Add salt (white pixels)
np.put(noisy_image, coords_salt, 255)
# Add pepper (black pixels)
np.put(noisy_image, coords_pepper, 0)
# Display the images
plt.subplot(131), plt.imshow(img, 'gray'), plt.title('Original Image')
plt.subplot(132), plt.imshow(noisy_image, 'gray'), plt.title('Noisy Image')
plt.show()

import cv2
import numpy as np
from matplotlib import pyplot as plt
# Load the image
img = cv2.imread('/content/flower.jpg', 0)  # Replace 'your_image_path.jpg' with the actual path
plt.imshow(img, cmap='gray')
plt.title('Original Image')
plt.show()
# Define a kernel for morphological operations
kernel = np.ones((5,5), np.uint8)
# Erosion
erosion = cv2.erode(img, kernel, iterations=1)
plt.imshow(erosion, cmap='gray')
plt.title('Erosion')
plt.show()
# Dilation
dilation = cv2.dilate(img, kernel, iterations=1)
plt.imshow(dilation, cmap='gray')
plt.title('Dilation')
plt.show()
# Opening (Erosion followed by Dilation)
opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)
plt.imshow(opening, cmap='gray')
plt.title('Opening')
plt.show()
# Closing (Dilation followed by Erosion)
closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)
plt.imshow(closing, cmap='gray')
plt.title('Closing')
plt.show()